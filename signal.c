/**
 * @file      signal.h
 * @author    Grégor Boirie <gregor.boirie@free.fr>
 * @date      04 Oct 2021
 * @copyright GNU Public License v3
 *
 * Process signal implementation
 *
 * @defgroup signal Signal
 *
 * This file is part of Utils
 *
 * Copyright (C) 2021 Grégor Boirie <gregor.boirie@free.fr>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
#include <utils/signal.h>

static sigset_t                __usig_inval_msk;
const sigset_t * const         usig_inval_msk = &__usig_inval_msk;
static sigset_t                __usig_empty_msk;
const sigset_t * const         usig_empty_msk = &__usig_empty_msk;
static sigset_t                __usig_full_msk;
const sigset_t * const         usig_full_msk = &__usig_full_msk;

static struct sigaction        __usig_dflt_act = {
	.sa_handler = SIG_DFL,
	.sa_flags   = 0
};
const struct sigaction * const usig_dflt_act = &__usig_dflt_act;

static void __ctor() __nothrow
usig_ctor(void)
{
	usig_emptyset(&__usig_empty_msk);
	__usig_inval_msk = __usig_empty_msk;
	usig_fillset(&__usig_full_msk);

	/* These are not catch'able. */
	usig_addset(&__usig_inval_msk, SIGKILL);
	usig_addset(&__usig_inval_msk, SIGSTOP);

	/*
	 * These ones are synchronously generated and directed at caller thread.
	 * Most of the time, these are generated as a consequence of hardware
	 * error conditions and require special handling.
	 * Moreover, according to POSIX, the behavior of a process is undefined
	 * after it ignores a SIGFPE, SIGILL, or SIGSEGV signal that was not
	 * generated by kill(2) or raise(3).
	 *
	 * Cowardly refuse to mess with them.
	 *
	 * See section 'NOTES' of sigaction(2) and section
	 * 'Signal mask and pending signals' of signal(7) ma pages.
	 */
	usig_addset(&__usig_inval_msk, SIGILL);  /* illegal instruction */
	usig_addset(&__usig_inval_msk, SIGFPE);  /* floating point exception */
	usig_addset(&__usig_inval_msk, SIGSEGV); /* invalid (virtual) memory access */
	usig_addset(&__usig_inval_msk, SIGBUS);  /* invalid physical memory access, e.g.:
	                                          * non-existent physical address,
	                                          * unaligned access,
	                                          * page in failure,
	                                          * ... */
	usig_addset(&__usig_inval_msk, SIGABRT); /* Mainly for assert() usage. */

	/*
	 * ]SIGSYS:SIGRTMIN[ are implicitly reserved by Glibc for internal
	 * purpose, i.e., NPTL / LinuxThread.
	 */

	usig_delset(&__usig_full_msk, SIGKILL);
	usig_delset(&__usig_full_msk, SIGSTOP);
	usig_delset(&__usig_full_msk, SIGILL);
	usig_delset(&__usig_full_msk, SIGFPE);
	usig_delset(&__usig_full_msk, SIGSEGV);
	usig_delset(&__usig_full_msk, SIGBUS);
	usig_delset(&__usig_full_msk, SIGABRT);

	__usig_dflt_act.sa_mask = __usig_empty_msk;
}

void
usig_setup_actions(const struct usig_new_act nevv[__restrict_arr],
                   struct usig_orig_act      orig[__restrict_arr],
                   unsigned int              nr)
{
	usig_assert(nevv);
	usig_assert(nr);

	unsigned int s;

	for (s = 0; s < nr; s++) {
		const struct usig_new_act * nact = &nevv[s];
		struct usig_orig_act *      oact = &orig[s];

		usig_assert(!usig_ismember(&__usig_inval_msk, nact->no));
		usig_assert(nact->act);

		if (oact) {
			oact->no = nact->no;
			usig_action(nact->no, nact->act, &oact->act);
		}
		else
			usig_action(nact->no, nact->act, NULL);
	}
}

void
usig_restore_actions(const struct usig_orig_act orig[__restrict_arr],
                     unsigned int               nr)
{
	usig_assert(orig);
	usig_assert(nr);

	unsigned int s;

	for (s = 0; s < nr; s++) {
		const struct usig_orig_act * oact = &orig[s];

		usig_assert(!usig_ismember(&__usig_inval_msk, oact->no));

		usig_action(oact->no, &oact->act, NULL);
	}
}

#if defined(CONFIG_UTILS_SIGNAL_FD)

int
usig_read_fd(int fd, struct signalfd_siginfo * infos, unsigned int count)
{
	usig_assert(fd >= 0);
	usig_assert(infos);
	usig_assert(count);

	ssize_t ret;

	ret = read(fd, infos, count * sizeof(*infos));
	if (ret < 0) {
		usig_assert(errno != EBADF);
		usig_assert(errno != EFAULT);
		usig_assert(errno != EINVAL);
		usig_assert(errno != EIO);
		usig_assert(errno != EISDIR);

		return -errno;
	}

	return ret ? (int)(ret / sizeof(*infos)) : -EAGAIN;
}

#endif /* defined(CONFIG_UTILS_SIGNAL_FD) */
