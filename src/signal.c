/******************************************************************************
 * SPDX-License-Identifier: LGPL-3.0-only
 *
 * This file is part of Utils.
 * Copyright (C) 2017-2024 Gr√©gor Boirie <gregor.boirie@free.fr>
 ******************************************************************************/

#include "utils/signal.h"

static sigset_t                __usig_inval_msk;
const sigset_t * const         usig_inval_msk = &__usig_inval_msk;
static sigset_t                __usig_empty_msk;
const sigset_t * const         usig_empty_msk = &__usig_empty_msk;
static sigset_t                __usig_full_msk;
const sigset_t * const         usig_full_msk = &__usig_full_msk;

static struct sigaction        __usig_dflt_act = {
	.sa_handler = SIG_DFL,
	.sa_flags   = 0
};
const struct sigaction * const usig_dflt_act = &__usig_dflt_act;

static __ctor() __utils_nothrow
void
usig_ctor(void)
{
	usig_emptyset(&__usig_empty_msk);
	__usig_inval_msk = __usig_empty_msk;
	usig_fillset(&__usig_full_msk);

	/* These are not catch'able. */
	usig_addset(&__usig_inval_msk, SIGKILL);
	usig_addset(&__usig_inval_msk, SIGSTOP);

	/*
	 * These ones are synchronously generated and directed at caller thread.
	 * Most of the time, these are generated as a consequence of hardware
	 * error conditions and require special handling.
	 * Moreover, according to POSIX, the behavior of a process is undefined
	 * after it ignores a SIGFPE, SIGILL, or SIGSEGV signal that was not
	 * generated by kill(2) or raise(3).
	 *
	 * Cowardly refuse to mess with them.
	 *
	 * See section 'NOTES' of sigaction(2) and section
	 * 'Signal mask and pending signals' of signal(7) ma pages.
	 */
	usig_addset(&__usig_inval_msk, SIGILL);  /* illegal instruction */
	usig_addset(&__usig_inval_msk, SIGFPE);  /* floating point exception */
	usig_addset(&__usig_inval_msk, SIGSEGV); /* invalid (virtual) memory access */
	usig_addset(&__usig_inval_msk, SIGBUS);  /* invalid physical memory access, e.g.:
	                                          * non-existent physical address,
	                                          * unaligned access,
	                                          * page in failure,
	                                          * ... */
	usig_addset(&__usig_inval_msk, SIGABRT); /* Mainly for assert() usage. */

	/*
	 * ]SIGSYS:SIGRTMIN[ are implicitly reserved by Glibc for internal
	 * purpose, i.e., NPTL / LinuxThread.
	 */

	usig_delset(&__usig_full_msk, SIGKILL);
	usig_delset(&__usig_full_msk, SIGSTOP);
	usig_delset(&__usig_full_msk, SIGILL);
	usig_delset(&__usig_full_msk, SIGFPE);
	usig_delset(&__usig_full_msk, SIGSEGV);
	usig_delset(&__usig_full_msk, SIGBUS);
	usig_delset(&__usig_full_msk, SIGABRT);

	__usig_dflt_act.sa_mask = __usig_empty_msk;
}

void
usig_setup_actions(const struct usig_new_act nevv[__restrict_arr],
                   struct usig_orig_act      orig[__restrict_arr],
                   unsigned int              nr)
{
	usig_assert_api(nevv);
	usig_assert_api(nr);

	unsigned int s;

	for (s = 0; s < nr; s++) {
		const struct usig_new_act * nact = &nevv[s];
		struct usig_orig_act *      oact = orig ? &orig[s] : NULL;

		usig_assert_api(!usig_ismember(&__usig_inval_msk,
		                               (int)nact->no));
		usig_assert_api(nact->act);

		if (oact) {
			oact->no = nact->no;
			usig_action((int)nact->no, nact->act, &oact->act);
		}
		else
			usig_action((int)nact->no, nact->act, NULL);
	}
}

void
usig_restore_actions(const struct usig_orig_act orig[__restrict_arr],
                     unsigned int               nr)
{
	usig_assert_api(orig);
	usig_assert_api(nr);

	unsigned int s;

	for (s = 0; s < nr; s++) {
		const struct usig_orig_act * oact = &orig[s];

		usig_assert_api(!usig_ismember(&__usig_inval_msk,
		                               (int)oact->no));

		usig_action((int)oact->no, &oact->act, NULL);
	}
}

#if defined(CONFIG_UTILS_SIGNAL_FD)

int
usig_read_fd(int fd, struct signalfd_siginfo * infos, unsigned int count)
{
	usig_assert_api(fd >= 0);
	usig_assert_api(infos);
	usig_assert_api(count);

	ssize_t ret;

	ret = ufd_read(fd, (char *)infos, count * sizeof(*infos));
	if (ret < 0) {
		usig_assert_api(errno != EIO);

		return -errno;
	}

	return ret ? (int)((size_t)ret / sizeof(*infos)) : -EAGAIN;
}

#endif /* defined(CONFIG_UTILS_SIGNAL_FD) */
